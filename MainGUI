#!/usr/bin/python3

#Script written by JasperTecHK, find it on my github! (If you didn't...somehow....)
#O.H.D.E.A.R. Opensource Heuristics for the DEtermination of Explicit Artwork Ratios

#Defining all the libraries required.
from multiprocessing import Pool
from lxml import html		#Nonstandard Library
import linecache
import json
import requests
import time
import tkinter			#Nonstandard Library
import PySimpleGUI as sg	#Nonstandard Library

#Defining all the variables.
url = "https://danbooru.donmai.us/counts/posts?tags="
bustsurl = "https://paizukan.com/html/"
count = 0
#global storedict
#storedict = 0
#PySimpleGUI Themes
sg.theme('Dark Blue 3')

#DEFining all the functions. Eh? Eh?
#... I'll show myself out.
def Dirscan ():	#Directory Scan. Used to allow user to locate the file to scrape.
	layout = [[sg.Text('Which list would you like to scour?')],
		[sg.InputText(), sg.FileBrowse(file_types=(""))],	# file_types here uses "" because I don't want to deal with cutting the file extention off, and the "All types", is really more of a ".", i.e. all files with an extention.
		[sg.Button('Confirm'), sg.Button('Cancel')]]
	window = sg.Window('Danbooru Comparison Script 2.0', layout)
	event, values = window.read()
	if event is None or event == 'Cancel':
		sg.popup('Cancelled.')
		exit()
	elif event == 'Confirm':
		sg.popup('Confirmed!')
		global filechoice
		filechoice = values[0]
	window.close()

def Setup ():	#Setup. Might not show up for the end user, depends if the file to scrape is on file.
	with open('Options3.json') as f:
		data=json.load(f)
		global filechoice
		global end
		global busts
		filtchk=filechoice.split('/')[-1]
		if filtchk in data["busts"]:
			busts = data["busts"][filtchk]
		if filtchk in data["ignored"]:
			end = ""
		elif filtchk in data["end"]:
			end = data["end"][filtchk]
		else:
			layout = [[sg.Text('Would you like to add any end tags to your list?')],
				[sg.InputText()],
				[sg.Button('Add this!'),sg.Button('Nope!')]]
			window = sg.Window('Danbooru Comparison Script 2.0', layout)
			event, values = window.read()
			if event is None or event == 'Nope!':
				sg.popup('Understood!')
				data["ignored"][str(filtchk)] = None
				with open('Options3.json', 'w') as g:
					g.write(json.dumps(data, sort_keys=True, indent='\t', separators=(',', ': ')))
				g.closed
				end = ""
			elif event == 'Add this!':
				sg.popup('Added to the settings!')
				data["end"][str(filtchk)] = values[0]
				with open('Options3.json', 'w') as g:
					g.write(json.dumps(data, sort_keys=True, indent='\t', separators=(',', ': ')))
				g.closed
				end = data["end"][filtchk]
			window.close()
	f.closed

def ReqParse (): # Requests url setup here.
	with open(filechoice) as r:
		global query
		global j
		global count
		global hold
		query = []
		hold = {}
		if end == "":
			for i in r:
				count += 1
				j = i.rstrip("\n")
				link = url + j
				query.append(link)	
				hold[j] = None
		else:
			for i in r:
				count += 1
				j = i.rstrip("\n")
				link = url + j + end
				query.append(link)
				hold[j] = None
	r.closed

#def ReqProc (toget): # Requests urls and processes it.
#	res = requests.get(toget)
#	tree = html.fromstring(res.content)
#	dbrest = tree.xpath('//div[@id="a-posts"]/text()')	#It stands for danbooru result temp. Git yer mind outta' gutter.
#	dbres = dbrest[1]
#	dbres = dbres.replace('\n', '').replace(' ', '')	#Processes and spits out the number.
#	j=toget.replace(url, '')
#	if not end == "":
#		j=j.replace(end, '')
#	print(dbres)
#	kpres = {j:dbres}
#	if hold[j]:
#		dbres = dbres.replace(':', ',')
#		hold[j].append(dbres)
#	else:
#		dbres = dbres.replace(':', '')
#		print(dbres)
#		hold[j]=dbres
	
#	print(hold)

#def Loading ():
	
#	while lode <= count

def ReqProc (garb): # Requests urls and processes it.
	global hold
	hold = {}
	for i in query:
		res = requests.get(i)
		tree = html.fromstring(res.content)
		dbrest = tree.xpath('//div[@id="a-posts"]/text()')      #It stands for danbooru result temp. Git yer mind outta' gutter.
		dbres = dbrest[1]
		dbres = dbres.replace(':', '').replace('\n', '').replace(' ', '')
		j=i.replace(url, '')
		if not end == "":
			j=j.replace(end, '')
		kpres = {j:dbres}
		hold.update(kpres)
	print(hold)

#def Libhold(rez): #Turns out, multiprocessing can be a bit tricky....
#	if storedict == 0:
#		i = 0
#		global store1
#		global store2
#		global storedict
#		global storecount
#		store1 = {}
#		store2 = {}
#		storedict = 1
#		storecount = 0
#	elif storedict == 1:
#		if storecount <= count:
#			store1.update(rez)
#			global storecount
#			storecount += 1
#			if storecount > count:
#				global storedict
#				global storecount
#				storedict = 2
#				storecount = 0
#				print(store1)
#	elif storedict == 2:
#		if storecount <= count:
#			store2.update(rez)
#			global storecount
#			storecount += 1
#			if storecount > count:
#				print(store1)
#				print(store2)


#Legacy code. I've always wanted to make a hashbox!		
#################################################################################################
#	print("Which list would you like to scour?")						#
#	with open('Options2.json') as f:							#
#		data = json.load(f)								#
#		for i in range(int(data["total"])):						#
#			[sg.text('Press {n} for {t}'.format(n=i,t=data[str(i)]["call"]))],	#
#	f.closed										#
#	sel = input()										#
#	conf = 0										#
#	OptionsMenu(sel)									#
#												#
#def OptionsMenu (sel):										#
#	if sel == 0:										#	
#		print("Who do you want to search for?")						#
#		sel = input()									#
#	elif(sel.isdigit()):									#
#		optvals = linecache.getline(Options,sel)					#
#		print(optvals)									#
#	else:											#
#		print("Your query is invalid.")							#
#		exit()										#
#	print("You want to open {}, correct?".format(sel))					#
#Script start!											#
#################################################################################################

Dirscan()
Setup()
ReqParse()
asycry = Pool()
#global hold
#hold = {}
asycry.map(ReqProc,query)
#while ulock == 1:
#	if count == 0:
#		print(hold)
#		ulock = 0	
#ReqProc()
print(hold)
